O motivo pelo qual um erro **Internal Server Error (HTTP 500)** é gerado quando o `loadUserByUsername` não encontra um usuário é que a exceção lançada pelo método `getCustomerEmail` é a **`ResourceNotFoundException`**, mas essa exceção não está sendo capturada explicitamente no fluxo do `AuthenticationProvider`.

Por padrão, o Spring Security espera que erros relacionados à autenticação lancem subclasses de **`AuthenticationException`** (como `UsernameNotFoundException`, `BadCredentialsException`, etc.). Como a exceção lançada (`ResourceNotFoundException`) não estende `AuthenticationException`, o Spring a trata como uma exceção inesperada, resultando em um erro HTTP 500.

### Solução
Para corrigir esse comportamento, você deve garantir que o método `loadUserByUsername` do `ProjectUserDetailsServiceImpl` lance uma exceção que seja uma subclasse de `AuthenticationException` quando um usuário não for encontrado. Você pode fazer isso ao capturar a `ResourceNotFoundException` e lançando uma `UsernameNotFoundException`, por exemplo:

```java
@Override
public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
    try {
        var customer = customerService.getCustomerEmail(username);
        List<GrantedAuthority> grantedAuthorities = List.of(new SimpleGrantedAuthority(customer.getRole()));
        return new User(customer.getEmail(), customer.getPassword(), grantedAuthorities);
    } catch (ResourceNotFoundException ex) {
        throw new UsernameNotFoundException("User not found: " + username, ex);
    }
}
```

### Por que usar `UsernameNotFoundException`?
O `UsernameNotFoundException` é uma subclasse de `AuthenticationException` e é especificamente projetado para indicar que o usuário não foi encontrado durante o processo de autenticação. O Spring Security irá capturar essa exceção e gerar corretamente uma resposta HTTP 401 (Unauthorized), ao invés de 500.

### Resultado esperado
Após a modificação, se um usuário não for encontrado:
1. O `loadUserByUsername` lançará uma `UsernameNotFoundException`.
2. O Spring Security retornará um HTTP 401 com uma mensagem apropriada.
3. O comportamento estará alinhado às práticas recomendadas do Spring Security.